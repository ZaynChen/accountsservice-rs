// This file was generated by gir (https://github.com/gtk-rs/gir)
// from accountsservice-gir-files
// DO NOT EDIT

use crate::{User, UserAccountType, ffi};
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::{boxed::Box as Box_, pin::Pin};

glib::wrapper! {
    /// A user manager object.
    ///
    /// ## Properties
    ///
    ///
    /// #### `exclude-usernames-list`
    ///  Readable | Writeable
    ///
    ///
    /// #### `has-multiple-users`
    ///  Readable | Writeable
    ///
    ///
    /// #### `include-usernames-list`
    ///  Readable | Writeable
    ///
    ///
    /// #### `is-loaded`
    ///  Readable
    ///
    /// ## Signals
    ///
    ///
    /// #### `user-added`
    ///  Emitted when a user is added to the user manager.
    ///
    ///
    ///
    ///
    /// #### `user-changed`
    ///  One of the users has changed
    ///
    ///
    ///
    ///
    /// #### `user-is-logged-in-changed`
    ///  One of the users has logged in or out.
    ///
    ///
    ///
    ///
    /// #### `user-removed`
    ///  Emitted when a user is removed from the user manager.
    ///
    ///
    ///
    /// # Implements
    ///
    /// [`UserManagerExt`][trait@crate::prelude::UserManagerExt]
    #[doc(alias = "ActUserManager")]
    pub struct UserManager(Object<ffi::ActUserManager, ffi::ActUserManagerClass>);

    match fn {
        type_ => || ffi::act_user_manager_get_type(),
    }
}

impl UserManager {
    pub const NONE: Option<&'static UserManager> = None;

    // rustdoc-stripper-ignore-next
    /// Creates a new builder-pattern struct instance to construct [`UserManager`] objects.
    ///
    /// This method returns an instance of [`UserManagerBuilder`](crate::builders::UserManagerBuilder) which can be used to create [`UserManager`] objects.
    pub fn builder() -> UserManagerBuilder {
        UserManagerBuilder::new()
    }

    /// Returns the user manager singleton instance. Calling this function will
    /// automatically being loading the user list if it isn't loaded already.
    /// The [`is-loaded`][struct@crate::UserManager#is-loaded] property will be set to [`true`] when the users
    /// are finished loading and then [`UserManagerExt::list_users()`][crate::prelude::UserManagerExt::list_users()] can be called.
    ///
    /// # Returns
    ///
    /// user manager object
    #[doc(alias = "act_user_manager_get_default")]
    #[doc(alias = "get_default")]
    #[allow(clippy::should_implement_trait)]
    pub fn default() -> Option<UserManager> {
        assert_initialized_main_thread!();
        unsafe { from_glib_none(ffi::act_user_manager_get_default()) }
    }
}

// rustdoc-stripper-ignore-next
/// A [builder-pattern] type to construct [`UserManager`] objects.
///
/// [builder-pattern]: https://doc.rust-lang.org/1.0.0/style/ownership/builders.html
#[must_use = "The builder must be built to be used"]
pub struct UserManagerBuilder {
    builder: glib::object::ObjectBuilder<'static, UserManager>,
}

impl UserManagerBuilder {
    fn new() -> Self {
        Self {
            builder: glib::object::Object::builder(),
        }
    }

    //pub fn exclude_usernames_list(self, exclude_usernames_list: /*Unimplemented*/Basic: Pointer) -> Self {
    //    Self { builder: self.builder.property("exclude-usernames-list", exclude_usernames_list), }
    //}

    pub fn has_multiple_users(self, has_multiple_users: bool) -> Self {
        Self {
            builder: self
                .builder
                .property("has-multiple-users", has_multiple_users),
        }
    }

    //pub fn include_usernames_list(self, include_usernames_list: /*Unimplemented*/Basic: Pointer) -> Self {
    //    Self { builder: self.builder.property("include-usernames-list", include_usernames_list), }
    //}

    // rustdoc-stripper-ignore-next
    /// Build the [`UserManager`].
    #[must_use = "Building the object from the builder is usually expensive and is not expected to have side effects"]
    pub fn build(self) -> UserManager {
        assert_initialized_main_thread!();
        self.builder.build()
    }
}

/// Trait containing all [`struct@UserManager`] methods.
///
/// # Implementors
///
/// [`UserManager`][struct@crate::UserManager]
pub trait UserManagerExt: IsA<UserManager> + 'static {
    /// Activate the session for a given user.
    /// ## `user`
    /// the user to activate
    ///
    /// # Returns
    ///
    /// whether successfully activated
    #[doc(alias = "act_user_manager_activate_user_session")]
    fn activate_user_session(&self, user: &User) -> bool {
        unsafe {
            from_glib(ffi::act_user_manager_activate_user_session(
                self.as_ref().to_glib_none().0,
                user.to_glib_none().0,
            ))
        }
    }

    /// Caches a user account so it shows up via [`list_users()`][Self::list_users()].
    /// ## `username`
    /// a user name
    ///
    /// # Returns
    ///
    /// user object
    #[doc(alias = "act_user_manager_cache_user")]
    fn cache_user(&self, username: &str) -> Result<User, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::act_user_manager_cache_user(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Asynchronously caches a user account so it shows up via
    /// [`list_users()`][Self::list_users()].
    ///
    /// For more details, see [`cache_user()`][Self::cache_user()], which
    /// is the synchronous version of this call.
    /// ## `username`
    /// a unix user name
    /// ## `cancellable`
    /// optional [`gio::Cancellable`][crate::gio::Cancellable] object,
    ///  [`None`] to ignore
    /// ## `callback`
    /// a `GAsyncReadyCallback` to call
    ///  when the request is satisfied
    #[doc(alias = "act_user_manager_cache_user_async")]
    fn cache_user_async<P: FnOnce(Result<User, glib::Error>) + 'static>(
        &self,
        username: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn cache_user_async_trampoline<
            P: FnOnce(Result<User, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::act_user_manager_cache_user_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = cache_user_async_trampoline::<P>;
        unsafe {
            ffi::act_user_manager_cache_user_async(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn cache_user_future(
        &self,
        username: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<User, glib::Error>> + 'static>> {
        let username = String::from(username);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.cache_user_async(&username, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    /// Check whether the user can switch to another session.
    ///
    /// # Returns
    ///
    /// whether we can switch to another session
    #[doc(alias = "act_user_manager_can_switch")]
    fn can_switch(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_manager_can_switch(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Creates a user account on the system.
    /// ## `username`
    /// a unix user name
    /// ## `fullname`
    /// a unix GECOS value
    /// ## `accounttype`
    /// a [`UserAccountType`][crate::UserAccountType]
    ///
    /// # Returns
    ///
    /// user object
    #[doc(alias = "act_user_manager_create_user")]
    fn create_user(
        &self,
        username: &str,
        fullname: &str,
        accounttype: UserAccountType,
    ) -> Result<User, glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let ret = ffi::act_user_manager_create_user(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                fullname.to_glib_none().0,
                accounttype.into_glib(),
                &mut error,
            );
            if error.is_null() {
                Ok(from_glib_full(ret))
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Asynchronously creates a user account on the system.
    ///
    /// For more details, see [`create_user()`][Self::create_user()], which
    /// is the synchronous version of this call.
    /// ## `username`
    /// a unix user name
    /// ## `fullname`
    /// a unix GECOS value
    /// ## `accounttype`
    /// a [`UserAccountType`][crate::UserAccountType]
    /// ## `cancellable`
    /// optional [`gio::Cancellable`][crate::gio::Cancellable] object,
    ///  [`None`] to ignore
    /// ## `callback`
    /// a `GAsyncReadyCallback` to call
    ///  when the request is satisfied
    #[doc(alias = "act_user_manager_create_user_async")]
    fn create_user_async<P: FnOnce(Result<User, glib::Error>) + 'static>(
        &self,
        username: &str,
        fullname: &str,
        accounttype: UserAccountType,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn create_user_async_trampoline<
            P: FnOnce(Result<User, glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                let ret = ffi::act_user_manager_create_user_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(from_glib_full(ret))
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = create_user_async_trampoline::<P>;
        unsafe {
            ffi::act_user_manager_create_user_async(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                fullname.to_glib_none().0,
                accounttype.into_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn create_user_future(
        &self,
        username: &str,
        fullname: &str,
        accounttype: UserAccountType,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<User, glib::Error>> + 'static>> {
        let username = String::from(username);
        let fullname = String::from(fullname);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.create_user_async(
                &username,
                &fullname,
                accounttype,
                Some(cancellable),
                move |res| {
                    send.resolve(res);
                },
            );
        }))
    }

    /// Deletes a user account on the system.
    /// ## `user`
    /// an [`User`][crate::User] object
    /// ## `remove_files`
    /// [`true`] to delete the users home directory
    ///
    /// # Returns
    ///
    /// [`true`] if the user account was successfully deleted
    #[doc(alias = "act_user_manager_delete_user")]
    fn delete_user(&self, user: &User, remove_files: bool) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::act_user_manager_delete_user(
                self.as_ref().to_glib_none().0,
                user.to_glib_none().0,
                remove_files.into_glib(),
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    /// Asynchronously deletes a user account from the system.
    ///
    /// For more details, see [`delete_user()`][Self::delete_user()], which
    /// is the synchronous version of this call.
    /// ## `user`
    /// a [`User`][crate::User] object
    /// ## `remove_files`
    /// [`true`] to delete the users home directory
    /// ## `cancellable`
    /// optional [`gio::Cancellable`][crate::gio::Cancellable] object,
    ///  [`None`] to ignore
    /// ## `callback`
    /// a `GAsyncReadyCallback` to call
    ///  when the request is satisfied
    #[doc(alias = "act_user_manager_delete_user_async")]
    fn delete_user_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        user: &User,
        remove_files: bool,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn delete_user_async_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::act_user_manager_delete_user_finish(_source_object as *mut _, res, &mut error);
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = delete_user_async_trampoline::<P>;
        unsafe {
            ffi::act_user_manager_delete_user_async(
                self.as_ref().to_glib_none().0,
                user.to_glib_none().0,
                remove_files.into_glib(),
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn delete_user_future(
        &self,
        user: &User,
        remove_files: bool,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let user = user.clone();
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.delete_user_async(&user, remove_files, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    /// Retrieves a pointer to the [`User`][crate::User] object for the login `username`
    /// from `self`. Trying to use this object before its
    /// [`is-loaded`][struct@crate::User#is-loaded] property is [`true`] will result in undefined
    /// behavior.
    /// ## `username`
    /// the login name of the user to get.
    ///
    /// # Returns
    ///
    /// [`User`][crate::User] object
    #[doc(alias = "act_user_manager_get_user")]
    #[doc(alias = "get_user")]
    fn user(&self, username: &str) -> Option<User> {
        unsafe {
            from_glib_none(ffi::act_user_manager_get_user(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
            ))
        }
    }

    /// Retrieves a pointer to the [`User`][crate::User] object for the user with the
    /// given uid from `self`. Trying to use this object before its
    /// [`is-loaded`][struct@crate::User#is-loaded] property is [`true`] will result in undefined
    /// behavior.
    /// ## `id`
    /// the uid of the user to get.
    ///
    /// # Returns
    ///
    /// [`User`][crate::User] object
    #[doc(alias = "act_user_manager_get_user_by_id")]
    #[doc(alias = "get_user_by_id")]
    fn user_by_id(&self, id: u32) -> Option<User> {
        unsafe {
            from_glib_none(ffi::act_user_manager_get_user_by_id(
                self.as_ref().to_glib_none().0,
                id,
            ))
        }
    }

    /// Switch the display to the login manager.
    ///
    /// # Returns
    ///
    /// whether successful or not
    #[doc(alias = "act_user_manager_goto_login_session")]
    fn goto_login_session(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_manager_goto_login_session(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Get a list of system user accounts
    ///
    /// # Returns
    ///
    /// List of [`User`][crate::User] objects
    #[doc(alias = "act_user_manager_list_users")]
    fn list_users(&self) -> Vec<User> {
        unsafe {
            FromGlibPtrContainer::from_glib_container(ffi::act_user_manager_list_users(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Check whether or not the accounts service is running.
    ///
    /// # Returns
    ///
    /// whether or not accounts service is running
    #[doc(alias = "act_user_manager_no_service")]
    fn no_service(&self) -> bool {
        unsafe {
            from_glib(ffi::act_user_manager_no_service(
                self.as_ref().to_glib_none().0,
            ))
        }
    }

    /// Releases all metadata about a user account, including icon,
    /// language and session. If the user account is from a remote
    /// server and the user has never logged in before, then that
    /// account will no longer show up in ListCachedUsers() output.
    /// ## `username`
    /// a user name
    ///
    /// # Returns
    ///
    /// [`true`] if successful, otherwise [`false`]
    #[doc(alias = "act_user_manager_uncache_user")]
    fn uncache_user(&self, username: &str) -> Result<(), glib::Error> {
        unsafe {
            let mut error = std::ptr::null_mut();
            let is_ok = ffi::act_user_manager_uncache_user(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                &mut error,
            );
            debug_assert_eq!(is_ok == glib::ffi::GFALSE, !error.is_null());
            if error.is_null() {
                Ok(())
            } else {
                Err(from_glib_full(error))
            }
        }
    }

    #[doc(alias = "act_user_manager_uncache_user_async")]
    fn uncache_user_async<P: FnOnce(Result<(), glib::Error>) + 'static>(
        &self,
        username: &str,
        cancellable: Option<&impl IsA<gio::Cancellable>>,
        callback: P,
    ) {
        let main_context = glib::MainContext::ref_thread_default();
        let is_main_context_owner = main_context.is_owner();
        let has_acquired_main_context = (!is_main_context_owner)
            .then(|| main_context.acquire().ok())
            .flatten();
        assert!(
            is_main_context_owner || has_acquired_main_context.is_some(),
            "Async operations only allowed if the thread is owning the MainContext"
        );

        let user_data: Box_<glib::thread_guard::ThreadGuard<P>> =
            Box_::new(glib::thread_guard::ThreadGuard::new(callback));
        unsafe extern "C" fn uncache_user_async_trampoline<
            P: FnOnce(Result<(), glib::Error>) + 'static,
        >(
            _source_object: *mut glib::gobject_ffi::GObject,
            res: *mut gio::ffi::GAsyncResult,
            user_data: glib::ffi::gpointer,
        ) {
            unsafe {
                let mut error = std::ptr::null_mut();
                ffi::act_user_manager_uncache_user_finish(
                    _source_object as *mut _,
                    res,
                    &mut error,
                );
                let result = if error.is_null() {
                    Ok(())
                } else {
                    Err(from_glib_full(error))
                };
                let callback: Box_<glib::thread_guard::ThreadGuard<P>> =
                    Box_::from_raw(user_data as *mut _);
                let callback: P = callback.into_inner();
                callback(result);
            }
        }
        let callback = uncache_user_async_trampoline::<P>;
        unsafe {
            ffi::act_user_manager_uncache_user_async(
                self.as_ref().to_glib_none().0,
                username.to_glib_none().0,
                cancellable.map(|p| p.as_ref()).to_glib_none().0,
                Some(callback),
                Box_::into_raw(user_data) as *mut _,
            );
        }
    }

    fn uncache_user_future(
        &self,
        username: &str,
    ) -> Pin<Box_<dyn std::future::Future<Output = Result<(), glib::Error>> + 'static>> {
        let username = String::from(username);
        Box_::pin(gio::GioFuture::new(self, move |obj, cancellable, send| {
            obj.uncache_user_async(&username, Some(cancellable), move |res| {
                send.resolve(res);
            });
        }))
    }

    //#[doc(alias = "exclude-usernames-list")]
    //fn exclude_usernames_list(&self) -> /*Unimplemented*/Basic: Pointer {
    //    ObjectExt::property(self.as_ref(), "exclude-usernames-list")
    //}

    //#[doc(alias = "exclude-usernames-list")]
    //fn set_exclude_usernames_list(&self, exclude_usernames_list: /*Unimplemented*/Basic: Pointer) {
    //    ObjectExt::set_property(self.as_ref(),"exclude-usernames-list", exclude_usernames_list)
    //}

    #[doc(alias = "has-multiple-users")]
    fn has_multiple_users(&self) -> bool {
        ObjectExt::property(self.as_ref(), "has-multiple-users")
    }

    #[doc(alias = "has-multiple-users")]
    fn set_has_multiple_users(&self, has_multiple_users: bool) {
        ObjectExt::set_property(self.as_ref(), "has-multiple-users", has_multiple_users)
    }

    //#[doc(alias = "include-usernames-list")]
    //fn include_usernames_list(&self) -> /*Unimplemented*/Basic: Pointer {
    //    ObjectExt::property(self.as_ref(), "include-usernames-list")
    //}

    //#[doc(alias = "include-usernames-list")]
    //fn set_include_usernames_list(&self, include_usernames_list: /*Unimplemented*/Basic: Pointer) {
    //    ObjectExt::set_property(self.as_ref(),"include-usernames-list", include_usernames_list)
    //}

    #[doc(alias = "is-loaded")]
    fn is_loaded(&self) -> bool {
        ObjectExt::property(self.as_ref(), "is-loaded")
    }

    /// Emitted when a user is added to the user manager.
    /// ## `user`
    /// the [`User`][crate::User] that was added
    #[doc(alias = "user-added")]
    fn connect_user_added<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_added_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            user: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserManager::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-added".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_added_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// One of the users has changed
    /// ## `user`
    /// the [`User`][crate::User] that changed
    #[doc(alias = "user-changed")]
    fn connect_user_changed<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_changed_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            user: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserManager::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// One of the users has logged in or out.
    /// ## `user`
    /// the [`User`][crate::User] that changed login status
    #[doc(alias = "user-is-logged-in-changed")]
    fn connect_user_is_logged_in_changed<F: Fn(&Self, &User) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn user_is_logged_in_changed_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            user: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserManager::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-is-logged-in-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_is_logged_in_changed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// Emitted when a user is removed from the user manager.
    /// ## `user`
    /// the [`User`][crate::User] that was removed
    #[doc(alias = "user-removed")]
    fn connect_user_removed<F: Fn(&Self, &User) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn user_removed_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P, &User) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            user: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(
                    UserManager::from_glib_borrow(this).unsafe_cast_ref(),
                    &from_glib_borrow(user),
                )
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"user-removed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    user_removed_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "exclude-usernames-list")]
    fn connect_exclude_usernames_list_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_exclude_usernames_list_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserManager::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::exclude-usernames-list".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_exclude_usernames_list_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "has-multiple-users")]
    fn connect_has_multiple_users_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_has_multiple_users_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserManager::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::has-multiple-users".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_has_multiple_users_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "include-usernames-list")]
    fn connect_include_usernames_list_notify<F: Fn(&Self) + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn notify_include_usernames_list_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserManager::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::include-usernames-list".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_include_usernames_list_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "is-loaded")]
    fn connect_is_loaded_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_loaded_trampoline<
            P: IsA<UserManager>,
            F: Fn(&P) + 'static,
        >(
            this: *mut ffi::ActUserManager,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(UserManager::from_glib_borrow(this).unsafe_cast_ref())
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::is-loaded".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_is_loaded_trampoline::<Self, F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl<O: IsA<UserManager>> UserManagerExt for O {}
