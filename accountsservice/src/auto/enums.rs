// This file was generated by gir (https://github.com/gtk-rs/gir)
// from accountsservice-gir-files
// DO NOT EDIT

use crate::ffi;
use glib::{prelude::*, translate::*};

/// Type of user account
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ActUserAccountType")]
pub enum UserAccountType {
    /// Normal non-administrative user
    #[doc(alias = "ACT_USER_ACCOUNT_TYPE_STANDARD")]
    Standard,
    /// Administrative user
    #[doc(alias = "ACT_USER_ACCOUNT_TYPE_ADMINISTRATOR")]
    Administrator,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for UserAccountType {
    type GlibType = ffi::ActUserAccountType;

    #[inline]
    fn into_glib(self) -> ffi::ActUserAccountType {
        match self {
            Self::Standard => ffi::ACT_USER_ACCOUNT_TYPE_STANDARD,
            Self::Administrator => ffi::ACT_USER_ACCOUNT_TYPE_ADMINISTRATOR,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ActUserAccountType> for UserAccountType {
    #[inline]
    unsafe fn from_glib(value: ffi::ActUserAccountType) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::ACT_USER_ACCOUNT_TYPE_STANDARD => Self::Standard,
            ffi::ACT_USER_ACCOUNT_TYPE_ADMINISTRATOR => Self::Administrator,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for UserAccountType {
    #[inline]
    #[doc(alias = "act_user_account_type_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::act_user_account_type_get_type()) }
    }
}

impl glib::HasParamSpec for UserAccountType {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for UserAccountType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UserAccountType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for UserAccountType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UserAccountType> for glib::Value {
    #[inline]
    fn from(v: UserAccountType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Various error codes returned by the accounts service.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ActUserManagerError")]
pub enum UserManagerError {
    /// Generic failure
    #[doc(alias = "ACT_USER_MANAGER_ERROR_FAILED")]
    Failed,
    /// The user already exists
    #[doc(alias = "ACT_USER_MANAGER_ERROR_USER_EXISTS")]
    UserExists,
    /// The user does not exist
    #[doc(alias = "ACT_USER_MANAGER_ERROR_USER_DOES_NOT_EXIST")]
    UserDoesNotExist,
    /// Permission denied
    #[doc(alias = "ACT_USER_MANAGER_ERROR_PERMISSION_DENIED")]
    PermissionDenied,
    /// Operation not supported
    #[doc(alias = "ACT_USER_MANAGER_ERROR_NOT_SUPPORTED")]
    NotSupported,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for UserManagerError {
    type GlibType = ffi::ActUserManagerError;

    #[inline]
    fn into_glib(self) -> ffi::ActUserManagerError {
        match self {
            Self::Failed => ffi::ACT_USER_MANAGER_ERROR_FAILED,
            Self::UserExists => ffi::ACT_USER_MANAGER_ERROR_USER_EXISTS,
            Self::UserDoesNotExist => ffi::ACT_USER_MANAGER_ERROR_USER_DOES_NOT_EXIST,
            Self::PermissionDenied => ffi::ACT_USER_MANAGER_ERROR_PERMISSION_DENIED,
            Self::NotSupported => ffi::ACT_USER_MANAGER_ERROR_NOT_SUPPORTED,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ActUserManagerError> for UserManagerError {
    #[inline]
    unsafe fn from_glib(value: ffi::ActUserManagerError) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::ACT_USER_MANAGER_ERROR_FAILED => Self::Failed,
            ffi::ACT_USER_MANAGER_ERROR_USER_EXISTS => Self::UserExists,
            ffi::ACT_USER_MANAGER_ERROR_USER_DOES_NOT_EXIST => Self::UserDoesNotExist,
            ffi::ACT_USER_MANAGER_ERROR_PERMISSION_DENIED => Self::PermissionDenied,
            ffi::ACT_USER_MANAGER_ERROR_NOT_SUPPORTED => Self::NotSupported,
            value => Self::__Unknown(value),
        }
    }
}

impl glib::error::ErrorDomain for UserManagerError {
    #[inline]
    fn domain() -> glib::Quark {
        skip_assert_initialized!();

        unsafe { from_glib(ffi::act_user_manager_error_quark()) }
    }

    #[inline]
    fn code(self) -> i32 {
        self.into_glib()
    }

    #[inline]
    #[allow(clippy::match_single_binding)]
    fn from(code: i32) -> Option<Self> {
        skip_assert_initialized!();
        match unsafe { from_glib(code) } {
            Self::__Unknown(_) => Some(Self::Failed),
            value => Some(value),
        }
    }
}

impl StaticType for UserManagerError {
    #[inline]
    #[doc(alias = "act_user_manager_error_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::act_user_manager_error_get_type()) }
    }
}

impl glib::HasParamSpec for UserManagerError {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for UserManagerError {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UserManagerError {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for UserManagerError {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UserManagerError> for glib::Value {
    #[inline]
    fn from(v: UserManagerError) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Mode for setting the user's password.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "ActUserPasswordMode")]
pub enum UserPasswordMode {
    /// Password set normally
    #[doc(alias = "ACT_USER_PASSWORD_MODE_REGULAR")]
    Regular,
    /// Password will be chosen at next login
    #[doc(alias = "ACT_USER_PASSWORD_MODE_SET_AT_LOGIN")]
    SetAtLogin,
    /// No password set
    #[doc(alias = "ACT_USER_PASSWORD_MODE_NONE")]
    None,
    #[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for UserPasswordMode {
    type GlibType = ffi::ActUserPasswordMode;

    #[inline]
    fn into_glib(self) -> ffi::ActUserPasswordMode {
        match self {
            Self::Regular => ffi::ACT_USER_PASSWORD_MODE_REGULAR,
            Self::SetAtLogin => ffi::ACT_USER_PASSWORD_MODE_SET_AT_LOGIN,
            Self::None => ffi::ACT_USER_PASSWORD_MODE_NONE,
            Self::__Unknown(value) => value,
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::ActUserPasswordMode> for UserPasswordMode {
    #[inline]
    unsafe fn from_glib(value: ffi::ActUserPasswordMode) -> Self {
        skip_assert_initialized!();

        match value {
            ffi::ACT_USER_PASSWORD_MODE_REGULAR => Self::Regular,
            ffi::ACT_USER_PASSWORD_MODE_SET_AT_LOGIN => Self::SetAtLogin,
            ffi::ACT_USER_PASSWORD_MODE_NONE => Self::None,
            value => Self::__Unknown(value),
        }
    }
}

impl StaticType for UserPasswordMode {
    #[inline]
    #[doc(alias = "act_user_password_mode_get_type")]
    fn static_type() -> glib::Type {
        unsafe { from_glib(ffi::act_user_password_mode_get_type()) }
    }
}

impl glib::HasParamSpec for UserPasswordMode {
    type ParamSpec = glib::ParamSpecEnum;
    type SetValue = Self;
    type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;

    fn param_spec_builder() -> Self::BuilderFn {
        Self::ParamSpec::builder_with_default
    }
}

impl glib::value::ValueType for UserPasswordMode {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for UserPasswordMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        unsafe { from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0)) }
    }
}

impl ToValue for UserPasswordMode {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<UserPasswordMode> for glib::Value {
    #[inline]
    fn from(v: UserPasswordMode) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}
