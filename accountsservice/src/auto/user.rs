// This file was generated by gir (https://github.com/gtk-rs/gir)
// from accountsservice-gir-files
// DO NOT EDIT

use crate::{UserAccountType, UserPasswordMode, ffi};
use glib::{
    object::ObjectType as _,
    prelude::*,
    signal::{SignalHandlerId, connect_raw},
    translate::*,
};
use std::boxed::Box as Box_;

glib::wrapper! {
    /// Represents a user account on the system.
    ///
    /// ## Properties
    ///
    ///
    /// #### `account-type`
    ///  Readable
    ///
    ///
    /// #### `automatic-login`
    ///  Readable
    ///
    ///
    /// #### `email`
    ///  Readable
    ///
    ///
    /// #### `home-directory`
    ///  Readable
    ///
    ///
    /// #### `icon-file`
    ///  Readable
    ///
    ///
    /// #### `is-loaded`
    ///  Readable
    ///
    ///
    /// #### `language`
    ///  The user’s locale, in the format
    /// `language[_territory][.codeset][`modifier`]`, where `language` is an
    /// ISO 639 language code, `territory` is an ISO 3166 country code, and
    /// `codeset` is a character set or encoding identifier like `ISO-8859-1`
    /// or `UTF-8`; as specified by [`setlocale(3)`](man:setlocale(3)).
    ///
    /// The locale may be the empty string, which means the user is using the
    /// system default locale.
    ///
    /// The property may be [`None`] if it wasn’t possible to load it from the
    /// daemon.
    ///
    /// Readable
    ///
    ///
    /// #### `local-account`
    ///  Readable
    ///
    ///
    /// #### `location`
    ///  Readable
    ///
    ///
    /// #### `locked`
    ///  Readable
    ///
    ///
    /// #### `login-frequency`
    ///  Readable
    ///
    ///
    /// #### `login-history`
    ///  Readable
    ///
    ///
    /// #### `login-time`
    ///  Readable
    ///
    ///
    /// #### `nonexistent`
    ///  Readable
    ///
    ///
    /// #### `password-hint`
    ///  Readable
    ///
    ///
    /// #### `password-mode`
    ///  Readable
    ///
    ///
    /// #### `real-name`
    ///  Readable
    ///
    ///
    /// #### `shell`
    ///  Readable
    ///
    ///
    /// #### `system-account`
    ///  Readable
    ///
    ///
    /// #### `uid`
    ///  Readable
    ///
    ///
    /// #### `user-name`
    ///  Readable
    ///
    ///
    /// #### `x-session`
    ///  Readable
    ///
    /// ## Signals
    ///
    ///
    /// #### `changed`
    ///  Emitted when the user accounts changes in some way.
    ///
    ///
    ///
    ///
    /// #### `sessions-changed`
    ///  Emitted when the list of sessions for this user changes.
    ///
    ///
    #[doc(alias = "ActUser")]
    pub struct User(Object<ffi::ActUser, ffi::ActUserClass>);

    match fn {
        type_ => || ffi::act_user_get_type(),
    }
}

impl User {
    /// Organize the user by login frequency and names.
    /// ## `user2`
    /// a user
    ///
    /// # Returns
    ///
    /// negative if `self` is before `user2`, zero if equal
    ///  or positive if `self` is after `user2`
    #[doc(alias = "act_user_collate")]
    pub fn collate(&self, user2: &User) -> i32 {
        unsafe { ffi::act_user_collate(self.to_glib_none().0, user2.to_glib_none().0) }
    }

    /// Retrieves the account type of `self`.
    ///
    /// # Returns
    ///
    /// a [`UserAccountType`][crate::UserAccountType]
    #[doc(alias = "act_user_get_account_type")]
    #[doc(alias = "get_account_type")]
    #[doc(alias = "account-type")]
    pub fn account_type(&self) -> UserAccountType {
        unsafe { from_glib(ffi::act_user_get_account_type(self.to_glib_none().0)) }
    }

    /// Returns whether or not [`User`][crate::User] is automatically logged in at boot time.
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_get_automatic_login")]
    #[doc(alias = "get_automatic_login")]
    #[doc(alias = "automatic-login")]
    pub fn is_automatic_login(&self) -> bool {
        unsafe { from_glib(ffi::act_user_get_automatic_login(self.to_glib_none().0)) }
    }

    /// Retrieves the email address set by `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_email")]
    #[doc(alias = "get_email")]
    pub fn email(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_email(self.to_glib_none().0)) }
    }

    /// Retrieves the home directory for `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_home_dir")]
    #[doc(alias = "get_home_dir")]
    pub fn home_dir(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_home_dir(self.to_glib_none().0)) }
    }

    /// Returns the path to the account icon belonging to `self`.
    ///
    /// # Returns
    ///
    /// a path to an icon
    #[doc(alias = "act_user_get_icon_file")]
    #[doc(alias = "get_icon_file")]
    #[doc(alias = "icon-file")]
    pub fn icon_file(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_icon_file(self.to_glib_none().0)) }
    }

    /// Returns the value of [`language`][struct@crate::User#language].
    ///
    /// # Returns
    ///
    /// the user’s language, or the empty string
    ///  if they are using the system default language, or [`None`] if there is no
    ///  connection to the daemon
    #[doc(alias = "act_user_get_language")]
    #[doc(alias = "get_language")]
    pub fn language(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_language(self.to_glib_none().0)) }
    }

    /// Returns the value of [`languages`][struct@crate::User#languages].
    ///
    /// # Returns
    ///
    /// the user’s preferred languages, or the
    ///  empty string if they are using the system default language, or [`None`]
    ///  if there is no connection to the daemon
    #[doc(alias = "act_user_get_languages")]
    #[doc(alias = "get_languages")]
    pub fn languages(&self) -> Vec<glib::GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_none(ffi::act_user_get_languages(self.to_glib_none().0))
        }
    }

    /// Retrieves the location set by `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_location")]
    #[doc(alias = "get_location")]
    pub fn location(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_location(self.to_glib_none().0)) }
    }

    /// Returns whether or not the [`User`][crate::User] account is locked.
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_get_locked")]
    #[doc(alias = "get_locked")]
    #[doc(alias = "locked")]
    pub fn is_locked(&self) -> bool {
        unsafe { from_glib(ffi::act_user_get_locked(self.to_glib_none().0)) }
    }

    /// Returns the number of times `self` has logged in.
    ///
    /// # Returns
    ///
    /// the login frequency
    #[doc(alias = "act_user_get_login_frequency")]
    #[doc(alias = "get_login_frequency")]
    #[doc(alias = "login-frequency")]
    pub fn login_frequency(&self) -> i32 {
        unsafe { ffi::act_user_get_login_frequency(self.to_glib_none().0) }
    }

    /// Returns the login history for `self`.
    ///
    /// # Returns
    ///
    /// a pointer to GVariant of type "a(xxa{sv})"
    /// which must not be modified or freed, or [`None`].
    #[doc(alias = "act_user_get_login_history")]
    #[doc(alias = "get_login_history")]
    #[doc(alias = "login-history")]
    pub fn login_history(&self) -> Option<glib::Variant> {
        unsafe { from_glib_none(ffi::act_user_get_login_history(self.to_glib_none().0)) }
    }

    /// Returns the last login time for `self`.
    ///
    /// # Returns
    ///
    /// the login time
    #[doc(alias = "act_user_get_login_time")]
    #[doc(alias = "get_login_time")]
    #[doc(alias = "login-time")]
    pub fn login_time(&self) -> i64 {
        unsafe { ffi::act_user_get_login_time(self.to_glib_none().0) }
    }

    /// Get the number of sessions for a user that are graphical and on the
    /// same seat as the session of the calling process.
    ///
    /// # Returns
    ///
    /// the number of sessions
    #[doc(alias = "act_user_get_num_sessions")]
    #[doc(alias = "get_num_sessions")]
    pub fn num_sessions(&self) -> u32 {
        unsafe { ffi::act_user_get_num_sessions(self.to_glib_none().0) }
    }

    /// Get the number of sessions for a user on any seat of any type.
    /// See also [`num_sessions()`][Self::num_sessions()].
    ///
    /// (Currently, this function is only implemented for systemd-logind.
    /// For ConsoleKit, it is equivalent to act_user_get_num_sessions.)
    ///
    /// # Returns
    ///
    /// the number of sessions
    #[doc(alias = "act_user_get_num_sessions_anywhere")]
    #[doc(alias = "get_num_sessions_anywhere")]
    pub fn num_sessions_anywhere(&self) -> u32 {
        unsafe { ffi::act_user_get_num_sessions_anywhere(self.to_glib_none().0) }
    }

    /// Returns the user accounts service object path of `self`,
    /// or [`None`] if `self` doesn't have an object path associated
    /// with it.
    ///
    /// # Returns
    ///
    /// the object path of the user
    #[doc(alias = "act_user_get_object_path")]
    #[doc(alias = "get_object_path")]
    pub fn object_path(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_object_path(self.to_glib_none().0)) }
    }

    /// Get the password expiration policy for a user.
    ///
    /// Note this function is synchronous and ignores errors.
    ///
    /// # Returns
    ///
    ///
    /// ## `expiration_time`
    /// location to write time users password expires
    ///
    /// ## `last_change_time`
    /// location to write time users password was last changed.
    ///
    /// ## `min_days_between_changes`
    /// location to write minimum number of days needed between password changes.
    ///
    /// ## `max_days_between_changes`
    /// location to write maximum number of days password can stay unchanged.
    ///
    /// ## `days_to_warn`
    /// location to write number of days to warn user password is about to expire.
    ///
    /// ## `days_after_expiration_until_lock`
    /// location to write number of days account will be locked after password expires.
    #[doc(alias = "act_user_get_password_expiration_policy")]
    #[doc(alias = "get_password_expiration_policy")]
    pub fn password_expiration_policy(&self) -> (i64, i64, i64, i64, i64, i64) {
        unsafe {
            let mut expiration_time = std::mem::MaybeUninit::uninit();
            let mut last_change_time = std::mem::MaybeUninit::uninit();
            let mut min_days_between_changes = std::mem::MaybeUninit::uninit();
            let mut max_days_between_changes = std::mem::MaybeUninit::uninit();
            let mut days_to_warn = std::mem::MaybeUninit::uninit();
            let mut days_after_expiration_until_lock = std::mem::MaybeUninit::uninit();
            ffi::act_user_get_password_expiration_policy(
                self.to_glib_none().0,
                expiration_time.as_mut_ptr(),
                last_change_time.as_mut_ptr(),
                min_days_between_changes.as_mut_ptr(),
                max_days_between_changes.as_mut_ptr(),
                days_to_warn.as_mut_ptr(),
                days_after_expiration_until_lock.as_mut_ptr(),
            );
            (
                expiration_time.assume_init(),
                last_change_time.assume_init(),
                min_days_between_changes.assume_init(),
                max_days_between_changes.assume_init(),
                days_to_warn.assume_init(),
                days_after_expiration_until_lock.assume_init(),
            )
        }
    }

    /// Retrieves the password hint set by `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_password_hint")]
    #[doc(alias = "get_password_hint")]
    #[doc(alias = "password-hint")]
    pub fn password_hint(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_password_hint(self.to_glib_none().0)) }
    }

    /// Retrieves the password mode of `self`.
    ///
    /// # Returns
    ///
    /// a [`UserPasswordMode`][crate::UserPasswordMode]
    #[doc(alias = "act_user_get_password_mode")]
    #[doc(alias = "get_password_mode")]
    #[doc(alias = "password-mode")]
    pub fn password_mode(&self) -> UserPasswordMode {
        unsafe { from_glib(ffi::act_user_get_password_mode(self.to_glib_none().0)) }
    }

    /// Returns the id of the primary session of `self`, or [`None`] if `self`
    /// has no primary session. The primary session will always be
    /// graphical and will be chosen from the sessions on the same seat as
    /// the seat of the session of the calling process.
    ///
    /// # Returns
    ///
    /// the id of the primary session of the user
    #[doc(alias = "act_user_get_primary_session_id")]
    #[doc(alias = "get_primary_session_id")]
    pub fn primary_session_id(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_primary_session_id(self.to_glib_none().0)) }
    }

    /// Retrieves the display name of `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_real_name")]
    #[doc(alias = "get_real_name")]
    #[doc(alias = "real-name")]
    pub fn real_name(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_real_name(self.to_glib_none().0)) }
    }

    /// Returns whether or not the [`User`][crate::User] account has retained state in accountsservice.
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_get_saved")]
    #[doc(alias = "get_saved")]
    pub fn is_saved(&self) -> bool {
        unsafe { from_glib(ffi::act_user_get_saved(self.to_glib_none().0)) }
    }

    /// Returns the path to the configured session for `self`.
    ///
    /// # Returns
    ///
    /// a path to an icon
    #[doc(alias = "act_user_get_session")]
    #[doc(alias = "get_session")]
    pub fn session(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_session(self.to_glib_none().0)) }
    }

    /// Returns the type of the configured session for `self`.
    ///
    /// # Returns
    ///
    /// a path to an icon
    #[doc(alias = "act_user_get_session_type")]
    #[doc(alias = "get_session_type")]
    pub fn session_type(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_session_type(self.to_glib_none().0)) }
    }

    /// Retrieves the shell assigned to `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_shell")]
    #[doc(alias = "get_shell")]
    pub fn shell(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_shell(self.to_glib_none().0)) }
    }

    /// Retrieves the ID of `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_uid")]
    #[doc(alias = "get_uid")]
    pub fn uid(&self) -> u32 {
        unsafe { ffi::act_user_get_uid(self.to_glib_none().0) }
    }

    /// Retrieves the login name of `self`.
    ///
    /// # Returns
    ///
    /// a pointer to an array of characters which must not be modified or
    ///  freed, or [`None`].
    #[doc(alias = "act_user_get_user_name")]
    #[doc(alias = "get_user_name")]
    #[doc(alias = "user-name")]
    pub fn user_name(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_user_name(self.to_glib_none().0)) }
    }

    /// Returns the path to the configured X session for `self`.
    ///
    /// # Returns
    ///
    /// a path to an icon
    #[doc(alias = "act_user_get_x_session")]
    #[doc(alias = "get_x_session")]
    #[doc(alias = "x-session")]
    pub fn x_session(&self) -> Option<glib::GString> {
        unsafe { from_glib_none(ffi::act_user_get_x_session(self.to_glib_none().0)) }
    }

    /// Determines whether or not the user object is loaded and ready to read from.
    /// [`is-loaded`][struct@crate::UserManager#is-loaded] property must be [`true`] before calling
    /// [`UserManagerExt::list_users()`][crate::prelude::UserManagerExt::list_users()]
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_is_loaded")]
    #[doc(alias = "is-loaded")]
    pub fn is_loaded(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_loaded(self.to_glib_none().0)) }
    }

    /// Retrieves whether the user is a local account or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the user is local
    #[doc(alias = "act_user_is_local_account")]
    pub fn is_local_account(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_local_account(self.to_glib_none().0)) }
    }

    /// Returns whether or not [`User`][crate::User] is currently graphically logged in
    /// on the same seat as the seat of the session of the calling process.
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_is_logged_in")]
    pub fn is_logged_in(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_logged_in(self.to_glib_none().0)) }
    }

    /// Returns whether or not [`User`][crate::User] is currently logged in in any way
    /// whatsoever. See also [`is_logged_in()`][Self::is_logged_in()].
    ///
    /// (Currently, this function is only implemented for systemd-logind.
    /// For ConsoleKit, it is equivalent to act_user_is_logged_in.)
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_is_logged_in_anywhere")]
    pub fn is_logged_in_anywhere(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_logged_in_anywhere(self.to_glib_none().0)) }
    }

    /// Retrieves whether the user is nonexistent or not.
    ///
    /// # Returns
    ///
    /// [`true`] if the user is nonexistent
    #[doc(alias = "act_user_is_nonexistent")]
    pub fn is_nonexistent(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_nonexistent(self.to_glib_none().0)) }
    }

    /// Returns whether or not [`User`][crate::User] represents a 'system account' like
    /// 'root' or 'nobody'.
    ///
    /// # Returns
    ///
    /// [`true`] or [`false`]
    #[doc(alias = "act_user_is_system_account")]
    pub fn is_system_account(&self) -> bool {
        unsafe { from_glib(ffi::act_user_is_system_account(self.to_glib_none().0)) }
    }

    /// Changes the account type of `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `account_type`
    /// a [`UserAccountType`][crate::UserAccountType]
    #[doc(alias = "act_user_set_account_type")]
    pub fn set_account_type(&self, account_type: UserAccountType) {
        unsafe {
            ffi::act_user_set_account_type(self.to_glib_none().0, account_type.into_glib());
        }
    }

    /// If enabled is set to [`true`] then this user will automatically be logged in
    /// at boot up time. Only one user can be configured to auto login at any given
    /// time, so subsequent calls to [`set_automatic_login()`][Self::set_automatic_login()] override previous
    /// calls.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `enabled`
    /// whether or not to autologin for user.
    #[doc(alias = "act_user_set_automatic_login")]
    pub fn set_automatic_login(&self, enabled: bool) {
        unsafe {
            ffi::act_user_set_automatic_login(self.to_glib_none().0, enabled.into_glib());
        }
    }

    /// Assigns a new email to `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `email`
    /// an email address
    #[doc(alias = "act_user_set_email")]
    pub fn set_email(&self, email: &str) {
        unsafe {
            ffi::act_user_set_email(self.to_glib_none().0, email.to_glib_none().0);
        }
    }

    /// Assigns a new icon for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `icon_file`
    /// path to an icon
    #[doc(alias = "act_user_set_icon_file")]
    pub fn set_icon_file(&self, icon_file: &str) {
        unsafe {
            ffi::act_user_set_icon_file(self.to_glib_none().0, icon_file.to_glib_none().0);
        }
    }

    /// Assigns a new locale for `self`, setting [`language`][struct@crate::User#language].
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `language`
    /// a locale (for example, `en_US.utf8`), or the empty
    ///  string to use the system default locale
    #[doc(alias = "act_user_set_language")]
    pub fn set_language(&self, language: &str) {
        unsafe {
            ffi::act_user_set_language(self.to_glib_none().0, language.to_glib_none().0);
        }
    }

    /// Assigns preferred languages for `self`, setting [`languages`][struct@crate::User#languages], and
    /// overriding [`language`][struct@crate::User#language] with the first item in the list if there is one.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `languages`
    /// an array of locale (for example, `en_US.utf8`), or
    ///  the empty string to use the system default locale
    #[doc(alias = "act_user_set_languages")]
    pub fn set_languages(&self, languages: &[&str]) {
        unsafe {
            ffi::act_user_set_languages(self.to_glib_none().0, languages.to_glib_none().0);
        }
    }

    /// Assigns a new location for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `location`
    /// a location
    #[doc(alias = "act_user_set_location")]
    pub fn set_location(&self, location: &str) {
        unsafe {
            ffi::act_user_set_location(self.to_glib_none().0, location.to_glib_none().0);
        }
    }

    /// Note this function is synchronous and ignores errors.
    /// ## `locked`
    /// whether or not the account is locked
    #[doc(alias = "act_user_set_locked")]
    pub fn set_locked(&self, locked: bool) {
        unsafe {
            ffi::act_user_set_locked(self.to_glib_none().0, locked.into_glib());
        }
    }

    /// Changes the password of `self` to `password`.
    /// `hint` is displayed to the user if they forget the password.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `password`
    /// a password
    /// ## `hint`
    /// a hint to help user recall password
    #[doc(alias = "act_user_set_password")]
    pub fn set_password(&self, password: &str, hint: &str) {
        unsafe {
            ffi::act_user_set_password(
                self.to_glib_none().0,
                password.to_glib_none().0,
                hint.to_glib_none().0,
            );
        }
    }

    /// Set the password expiration policy for a user.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `min_days_between_changes`
    /// location to write minimum number of days needed between password changes.
    /// ## `max_days_between_changes`
    /// location to write maximum number of days password can stay unchanged.
    /// ## `days_to_warn`
    /// location to write number of days to warn user password is about to expire.
    /// ## `days_after_expiration_until_lock`
    /// location to write number of days account will be locked after password expires.
    #[doc(alias = "act_user_set_password_expiration_policy")]
    pub fn set_password_expiration_policy(
        &self,
        min_days_between_changes: i64,
        max_days_between_changes: i64,
        days_to_warn: i64,
        days_after_expiration_until_lock: i64,
    ) {
        unsafe {
            ffi::act_user_set_password_expiration_policy(
                self.to_glib_none().0,
                min_days_between_changes,
                max_days_between_changes,
                days_to_warn,
                days_after_expiration_until_lock,
            );
        }
    }

    #[doc(alias = "act_user_set_password_hint")]
    pub fn set_password_hint(&self, hint: &str) {
        unsafe {
            ffi::act_user_set_password_hint(self.to_glib_none().0, hint.to_glib_none().0);
        }
    }

    /// Changes the password of `self`. If `password_mode` is
    /// ACT_USER_PASSWORD_MODE_SET_AT_LOGIN then the user will
    /// be asked for a new password at the next login. If `password_mode`
    /// is ACT_USER_PASSWORD_MODE_NONE then the user will not require
    /// a password to log in.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `password_mode`
    /// a [`UserPasswordMode`][crate::UserPasswordMode]
    #[doc(alias = "act_user_set_password_mode")]
    pub fn set_password_mode(&self, password_mode: UserPasswordMode) {
        unsafe {
            ffi::act_user_set_password_mode(self.to_glib_none().0, password_mode.into_glib());
        }
    }

    /// Assigns a new name for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `real_name`
    /// a new name
    #[doc(alias = "act_user_set_real_name")]
    pub fn set_real_name(&self, real_name: &str) {
        unsafe {
            ffi::act_user_set_real_name(self.to_glib_none().0, real_name.to_glib_none().0);
        }
    }

    /// Assigns a new session for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `session`
    /// a session (e.g. gnome)
    #[doc(alias = "act_user_set_session")]
    pub fn set_session(&self, session: &str) {
        unsafe {
            ffi::act_user_set_session(self.to_glib_none().0, session.to_glib_none().0);
        }
    }

    /// Assigns a type to the session for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `session_type`
    /// a type of session (e.g. "wayland" or "x11")
    #[doc(alias = "act_user_set_session_type")]
    pub fn set_session_type(&self, session_type: &str) {
        unsafe {
            ffi::act_user_set_session_type(self.to_glib_none().0, session_type.to_glib_none().0);
        }
    }

    /// Set the user expiration policy for a user.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `expiration_time`
    /// location to write users expires timestamp
    #[doc(alias = "act_user_set_user_expiration_policy")]
    pub fn set_user_expiration_policy(&self, expiration_time: i64) {
        unsafe {
            ffi::act_user_set_user_expiration_policy(self.to_glib_none().0, expiration_time);
        }
    }

    /// Assigns a new username for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `user_name`
    /// a new user name
    #[doc(alias = "act_user_set_user_name")]
    pub fn set_user_name(&self, user_name: &str) {
        unsafe {
            ffi::act_user_set_user_name(self.to_glib_none().0, user_name.to_glib_none().0);
        }
    }

    /// Assigns a new x session for `self`.
    ///
    /// Note this function is synchronous and ignores errors.
    /// ## `x_session`
    /// an x session (e.g. gnome)
    #[doc(alias = "act_user_set_x_session")]
    pub fn set_x_session(&self, x_session: &str) {
        unsafe {
            ffi::act_user_set_x_session(self.to_glib_none().0, x_session.to_glib_none().0);
        }
    }

    #[doc(alias = "home-directory")]
    pub fn home_directory(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "home-directory")
    }

    /// Emitted when the user accounts changes in some way.
    #[doc(alias = "changed")]
    pub fn connect_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    changed_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    /// Emitted when the list of sessions for this user changes.
    #[doc(alias = "sessions-changed")]
    pub fn connect_sessions_changed<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn sessions_changed_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"sessions-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    sessions_changed_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "account-type")]
    pub fn connect_account_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_account_type_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::account-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_account_type_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "automatic-login")]
    pub fn connect_automatic_login_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_automatic_login_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::automatic-login".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_automatic_login_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "email")]
    pub fn connect_email_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_email_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::email".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_email_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "home-directory")]
    pub fn connect_home_directory_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_home_directory_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::home-directory".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_home_directory_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "icon-file")]
    pub fn connect_icon_file_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_icon_file_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::icon-file".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_icon_file_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "is-loaded")]
    pub fn connect_is_loaded_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_is_loaded_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::is-loaded".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_is_loaded_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "language")]
    pub fn connect_language_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_language_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::language".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_language_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "local-account")]
    pub fn connect_local_account_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_local_account_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::local-account".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_local_account_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "location")]
    pub fn connect_location_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_location_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::location".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_location_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "locked")]
    pub fn connect_locked_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_locked_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::locked".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_locked_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "login-frequency")]
    pub fn connect_login_frequency_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_frequency_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::login-frequency".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_login_frequency_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "login-history")]
    pub fn connect_login_history_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_history_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::login-history".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_login_history_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "login-time")]
    pub fn connect_login_time_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_login_time_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::login-time".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_login_time_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "nonexistent")]
    pub fn connect_nonexistent_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_nonexistent_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::nonexistent".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_nonexistent_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password-hint")]
    pub fn connect_password_hint_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_hint_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password-hint".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_hint_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "password-mode")]
    pub fn connect_password_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_password_mode_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::password-mode".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_password_mode_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "real-name")]
    pub fn connect_real_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_real_name_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::real-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_real_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "shell")]
    pub fn connect_shell_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_shell_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::shell".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_shell_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "system-account")]
    pub fn connect_system_account_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_system_account_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::system-account".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_system_account_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "uid")]
    pub fn connect_uid_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_uid_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::uid".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_uid_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "user-name")]
    pub fn connect_user_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_user_name_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::user-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_user_name_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "x-session")]
    pub fn connect_x_session_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_x_session_trampoline<F: Fn(&User) + 'static>(
            this: *mut ffi::ActUser,
            _param_spec: glib::ffi::gpointer,
            f: glib::ffi::gpointer,
        ) {
            unsafe {
                let f: &F = &*(f as *const F);
                f(&from_glib_borrow(this))
            }
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                c"notify::x-session".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(
                    notify_x_session_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}
