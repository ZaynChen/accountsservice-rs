// This file was generated by gir (https://github.com/gtk-rs/gir)
// from accountsservice-gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(
    clippy::approx_constant,
    clippy::type_complexity,
    clippy::unreadable_literal,
    clippy::upper_case_acronyms
)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use gio_sys as gio;
use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use libc::{FILE, intptr_t, off_t, size_t, ssize_t, time_t, uintptr_t};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};
#[allow(unused_imports)]
use std::ffi::{
    c_char, c_double, c_float, c_int, c_long, c_short, c_uchar, c_uint, c_ulong, c_ushort, c_void,
};

#[allow(unused_imports)]
use glib::{GType, gboolean, gconstpointer, gpointer};

// Enums
pub type ActUserAccountType = c_int;
pub const ACT_USER_ACCOUNT_TYPE_STANDARD: ActUserAccountType = 0;
pub const ACT_USER_ACCOUNT_TYPE_ADMINISTRATOR: ActUserAccountType = 1;

pub type ActUserManagerError = c_int;
pub const ACT_USER_MANAGER_ERROR_FAILED: ActUserManagerError = 0;
pub const ACT_USER_MANAGER_ERROR_USER_EXISTS: ActUserManagerError = 1;
pub const ACT_USER_MANAGER_ERROR_USER_DOES_NOT_EXIST: ActUserManagerError = 2;
pub const ACT_USER_MANAGER_ERROR_PERMISSION_DENIED: ActUserManagerError = 3;
pub const ACT_USER_MANAGER_ERROR_NOT_SUPPORTED: ActUserManagerError = 4;

pub type ActUserPasswordMode = c_int;
pub const ACT_USER_PASSWORD_MODE_REGULAR: ActUserPasswordMode = 0;
pub const ACT_USER_PASSWORD_MODE_SET_AT_LOGIN: ActUserPasswordMode = 1;
pub const ACT_USER_PASSWORD_MODE_NONE: ActUserPasswordMode = 2;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActUserClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for ActUserClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ActUserClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActUserManagerClass {
    pub parent_class: gobject::GObjectClass,
    pub user_added: Option<unsafe extern "C" fn(*mut ActUserManager, *mut ActUser)>,
    pub user_removed: Option<unsafe extern "C" fn(*mut ActUserManager, *mut ActUser)>,
    pub user_is_logged_in_changed: Option<unsafe extern "C" fn(*mut ActUserManager, *mut ActUser)>,
    pub user_changed: Option<unsafe extern "C" fn(*mut ActUserManager, *mut ActUser)>,
}

impl ::std::fmt::Debug for ActUserManagerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ActUserManagerClass @ {self:p}"))
            .field("parent_class", &self.parent_class)
            .field("user_added", &self.user_added)
            .field("user_removed", &self.user_removed)
            .field("user_is_logged_in_changed", &self.user_is_logged_in_changed)
            .field("user_changed", &self.user_changed)
            .finish()
    }
}

// Classes
#[repr(C)]
#[allow(dead_code)]
pub struct ActUser {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for ActUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ActUser @ {self:p}")).finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct ActUserManager {
    pub parent: gobject::GObject,
    pub deprecated: gpointer,
}

impl ::std::fmt::Debug for ActUserManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("ActUserManager @ {self:p}"))
            .field("parent", &self.parent)
            .finish()
    }
}

unsafe extern "C" {

    //=========================================================================
    // ActUserAccountType
    //=========================================================================
    pub fn act_user_account_type_get_type() -> GType;

    //=========================================================================
    // ActUserManagerError
    //=========================================================================
    pub fn act_user_manager_error_get_type() -> GType;
    pub fn act_user_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // ActUserPasswordMode
    //=========================================================================
    pub fn act_user_password_mode_get_type() -> GType;

    //=========================================================================
    // ActUser
    //=========================================================================
    pub fn act_user_get_type() -> GType;
    pub fn act_user_collate(user1: *mut ActUser, user2: *mut ActUser) -> c_int;
    pub fn act_user_get_account_type(user: *mut ActUser) -> ActUserAccountType;
    pub fn act_user_get_automatic_login(user: *mut ActUser) -> gboolean;
    pub fn act_user_get_email(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_home_dir(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_icon_file(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_language(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_languages(user: *mut ActUser) -> *const *const c_char;
    pub fn act_user_get_location(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_locked(user: *mut ActUser) -> gboolean;
    pub fn act_user_get_login_frequency(user: *mut ActUser) -> c_int;
    pub fn act_user_get_login_history(user: *mut ActUser) -> *const glib::GVariant;
    pub fn act_user_get_login_time(user: *mut ActUser) -> i64;
    pub fn act_user_get_num_sessions(user: *mut ActUser) -> c_uint;
    pub fn act_user_get_num_sessions_anywhere(user: *mut ActUser) -> c_uint;
    pub fn act_user_get_object_path(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_password_expiration_policy(
        user: *mut ActUser,
        expiration_time: *mut i64,
        last_change_time: *mut i64,
        min_days_between_changes: *mut i64,
        max_days_between_changes: *mut i64,
        days_to_warn: *mut i64,
        days_after_expiration_until_lock: *mut i64,
    );
    pub fn act_user_get_password_hint(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_password_mode(user: *mut ActUser) -> ActUserPasswordMode;
    pub fn act_user_get_primary_session_id(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_real_name(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_saved(user: *mut ActUser) -> gboolean;
    pub fn act_user_get_session(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_session_type(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_shell(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_uid(user: *mut ActUser) -> uid_t;
    pub fn act_user_get_user_name(user: *mut ActUser) -> *const c_char;
    pub fn act_user_get_x_session(user: *mut ActUser) -> *const c_char;
    pub fn act_user_is_loaded(user: *mut ActUser) -> gboolean;
    pub fn act_user_is_local_account(user: *mut ActUser) -> gboolean;
    pub fn act_user_is_logged_in(user: *mut ActUser) -> gboolean;
    pub fn act_user_is_logged_in_anywhere(user: *mut ActUser) -> gboolean;
    pub fn act_user_is_nonexistent(user: *mut ActUser) -> gboolean;
    pub fn act_user_is_system_account(user: *mut ActUser) -> gboolean;
    pub fn act_user_set_account_type(user: *mut ActUser, account_type: ActUserAccountType);
    pub fn act_user_set_automatic_login(user: *mut ActUser, enabled: gboolean);
    pub fn act_user_set_email(user: *mut ActUser, email: *const c_char);
    pub fn act_user_set_icon_file(user: *mut ActUser, icon_file: *const c_char);
    pub fn act_user_set_language(user: *mut ActUser, language: *const c_char);
    pub fn act_user_set_languages(user: *mut ActUser, languages: *const *const c_char);
    pub fn act_user_set_location(user: *mut ActUser, location: *const c_char);
    pub fn act_user_set_locked(user: *mut ActUser, locked: gboolean);
    pub fn act_user_set_password(user: *mut ActUser, password: *const c_char, hint: *const c_char);
    pub fn act_user_set_password_expiration_policy(
        user: *mut ActUser,
        min_days_between_changes: i64,
        max_days_between_changes: i64,
        days_to_warn: i64,
        days_after_expiration_until_lock: i64,
    );
    pub fn act_user_set_password_hint(user: *mut ActUser, hint: *const c_char);
    pub fn act_user_set_password_mode(user: *mut ActUser, password_mode: ActUserPasswordMode);
    pub fn act_user_set_real_name(user: *mut ActUser, real_name: *const c_char);
    pub fn act_user_set_session(user: *mut ActUser, session: *const c_char);
    pub fn act_user_set_session_type(user: *mut ActUser, session_type: *const c_char);
    pub fn act_user_set_user_expiration_policy(user: *mut ActUser, expiration_time: i64);
    pub fn act_user_set_user_name(user: *mut ActUser, user_name: *const c_char);
    pub fn act_user_set_x_session(user: *mut ActUser, x_session: *const c_char);

    //=========================================================================
    // ActUserManager
    //=========================================================================
    pub fn act_user_manager_get_type() -> GType;
    pub fn act_user_manager_get_default() -> *mut ActUserManager;
    pub fn act_user_manager_activate_user_session(
        manager: *mut ActUserManager,
        user: *mut ActUser,
    ) -> gboolean;
    pub fn act_user_manager_cache_user(
        manager: *mut ActUserManager,
        username: *const c_char,
        error: *mut *mut glib::GError,
    ) -> *mut ActUser;
    pub fn act_user_manager_cache_user_async(
        manager: *mut ActUserManager,
        username: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn act_user_manager_cache_user_finish(
        manager: *mut ActUserManager,
        result: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut ActUser;
    pub fn act_user_manager_can_switch(manager: *mut ActUserManager) -> gboolean;
    pub fn act_user_manager_create_user(
        manager: *mut ActUserManager,
        username: *const c_char,
        fullname: *const c_char,
        accounttype: ActUserAccountType,
        error: *mut *mut glib::GError,
    ) -> *mut ActUser;
    pub fn act_user_manager_create_user_async(
        manager: *mut ActUserManager,
        username: *const c_char,
        fullname: *const c_char,
        accounttype: ActUserAccountType,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn act_user_manager_create_user_finish(
        manager: *mut ActUserManager,
        result: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> *mut ActUser;
    pub fn act_user_manager_delete_user(
        manager: *mut ActUserManager,
        user: *mut ActUser,
        remove_files: gboolean,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn act_user_manager_delete_user_async(
        manager: *mut ActUserManager,
        user: *mut ActUser,
        remove_files: gboolean,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn act_user_manager_delete_user_finish(
        manager: *mut ActUserManager,
        result: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn act_user_manager_get_user(
        manager: *mut ActUserManager,
        username: *const c_char,
    ) -> *mut ActUser;
    pub fn act_user_manager_get_user_by_id(manager: *mut ActUserManager, id: uid_t)
    -> *mut ActUser;
    pub fn act_user_manager_goto_login_session(manager: *mut ActUserManager) -> gboolean;
    pub fn act_user_manager_list_users(manager: *mut ActUserManager) -> *mut glib::GSList;
    pub fn act_user_manager_no_service(manager: *mut ActUserManager) -> gboolean;
    pub fn act_user_manager_uncache_user(
        manager: *mut ActUserManager,
        username: *const c_char,
        error: *mut *mut glib::GError,
    ) -> gboolean;
    pub fn act_user_manager_uncache_user_async(
        manager: *mut ActUserManager,
        username: *const c_char,
        cancellable: *mut gio::GCancellable,
        callback: gio::GAsyncReadyCallback,
        user_data: gpointer,
    );
    pub fn act_user_manager_uncache_user_finish(
        manager: *mut ActUserManager,
        result: *mut gio::GAsyncResult,
        error: *mut *mut glib::GError,
    ) -> gboolean;

}
